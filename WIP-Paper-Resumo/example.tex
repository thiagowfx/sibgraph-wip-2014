%% % Gummi|063|=)

% ==========================================
% Sibgrapi 2014 paper
% Anderson Rocha, Diego Nehab, ...
% ==========================================

% Note that the a4paper option is mainly intended so that authors in
% countries using A4 can easily print to A4 and see how their papers will
% look in print - the typesetting of the document will not typically be
% affected with changes in paper size (but the bottom and side margins will).
% Use the testflow package mentioned above to verify correct handling of
% both paper sizes by the user's LaTeX system.
%
% Also note that the "draftcls" or "draftclsnofoot", not "draft", option
% should be used if it is desired that the figures are to be displayed in
% draft mode.
%
\documentclass[10pt, conference]{IEEEtran}

% our packages
\usepackage{caption}
\usepackage[utf8]{inputenc}
% end our packages

% *** MISC UTILITY PACKAGES ***
%
% \usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/tex-archive/macros/latex/contrib/oberdiek/
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.


% *** CITATION PACKAGES ***
%
% \usepackage{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 4.0 (2003-05-27) and later if using hyperref.sty. cite.sty does
% not currently provide for hyperlinked citations.
% The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/cite/
% The documentation is contained in the cite.sty file itself.



% *** GRAPHICS RELATED PACKAGES ***
%
\usepackage{subimages}
\setfigdir{imgs}

% *** MATH PACKAGES ***
%
\usepackage[cmex10]{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics. If using
% it, be sure to load this package with the cmex10 option to ensure that
% only type 1 fonts will utilized at all point sizes. Without this option,
% it is possible that some math symbols, particularly those within
% footnotes, will be rendered in bitmap form which will result in a
% document that can not be IEEE Xplore compliant!
%
% Also, note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/
\usepackage{amsthm}
\newtheorem{definition}{Definition}


% *** SPECIALIZED LIST PACKAGES ***
%
% \usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithms/
% There is also a support site at:
% http://algorithms.berlios.de/index.html
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithmicx/


% *** ALIGNMENT PACKAGES ***
%
% \usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/


% \usepackage{mdwmath}
% \usepackage{mdwtab}
% Also highly recommended is Mark Wooding's extremely powerful MDW tools,
% especially mdwmath.sty and mdwtab.sty which are used to format equations
% and tables, respectively. The MDWtools set is already installed on most
% LaTeX systems. The lastest version and documentation is available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/mdwtools/


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.

% \usepackage{eqparbox}
% Also of notable interest is Scott Pakin's eqparbox package for creating
% (automatically sized) equal width boxes - aka "natural width parboxes".
% Available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/eqparbox/


% *** PDF, URL AND HYPERLINK PACKAGES ***
%
% \usepackage{hyperref}

% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )

% correct bad hyphenation here
% \hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}
% paper title -- you can use linebreaks within to get better formatting as desired
\title{Extracting and Rendering Primitives from Point Clouds}

% -------------------------------------------------------------------------
% change the % on next lines to produce the final camera-ready version
\newif\iffinal
%\finalfalse
 \finaltrue
\newcommand{\jemsid}{12}
% -------------------------------------------------------------------------

\iffinal
\author{%
  \IEEEauthorblockN{Thiago Barroso Perrotta, Daniel Pinto Coutinho,  Ricardo Guerra Marroquim}
  \IEEEauthorblockA{%
    Federal University of Rio de Janeiro\\
    Rio de Janeiro, Brazil\\
    email: perrotta.thiago@poli.ufrj.br, \{dpcoutinho, marroquim\}@cos.ufrj.br}
}
% \and
% more author blocks here
% use a multiple column layout for up to two different affiliations
\else
\author{Thiago Barroso Perrotta \and Daniel Pinto Coutinho \and Ricardo Guerra Marroquim }
\fi

% for over three affiliations, or if they all won't fit within the width
% of the page, use this alternative format:
%
% \author{\IEEEauthorblockN{Michael Shell\IEEEauthorrefmark{1},
% Homer Simpson\IEEEauthorrefmark{2},
% James Kirk\IEEEauthorrefmark{3},
% Montgomery Scott\IEEEauthorrefmark{3} and
% Eldon Tyrell\IEEEauthorrefmark{4}}
% \IEEEauthorblockA{\IEEEauthorrefmark{1}School of Electrical and Computer Engineering\\
% Georgia Institute of Technology,
% Atlanta, Georgia 30332--0250\\ Email: see http://www.michaelshell.org/contact.html}
% \IEEEauthorblockA{\IEEEauthorrefmark{2}Twentieth Century Fox, Springfield, USA\\
% Email: homer@thesimpsons.com}
% \IEEEauthorblockA{\IEEEauthorrefmark{3}Starfleet Academy, San Francisco, California 96678-2391\\
% Telephone: (800) 555--1212, Fax: (888) 555--1212}
% \IEEEauthorblockA{\IEEEauthorrefmark{4}Tyrell Inc., 123 Replicant Street, Los Angeles, California 90210--4321}}


% -------------------------------------------------------------------------
% Special Sibgrapi teaser
%% \teaser{%
%% \oneimage{Teasing result of our method: from this data input (left), the relevant feature are extracted using our technique (middle), producing effective result (right).}{.99}{teaser.pdf}
%% }
%   -------------------------------------------------------------------------

\maketitle

% DO NOT USE SPECIAL CHARACTERS, SYMBOLS, OR MATH IN YOUR TITLE OR ABSTRACT.
% FIXME -- improve this
\begin{abstract}
In this work we provide a method to extract and render geometric primitives from point clouds, without the need to convert to polygon meshes. The extraction is realized in two steps: first the basic shapes are detected, then their boundaries are analyzed and stored in a convenient spatial data-structure. Finally, a ray-tracer is employed to directly visualize the extracted primitives.
\end{abstract}

% one or two words; separated by semicolon; from specific; to generic fields;
\begin{IEEEkeywords}
  point cloud; primitive detection; ray tracing
\end{IEEEkeywords}

\IEEEpeerreviewmaketitle

% Wherever Times is specified, Times Roman or Times New Roman may be used. If neither is available on your system, please use the font closest in appearance to Times. Avoid using bit-mapped fonts if possible. True-Type 1 or Open Type fonts are preferred. Please embed symbol fonts, as well, for math, etc.

% \figref{overview}.
% \cite{Sibgrapi2014}.
% \ref{tab:perfs}

\section{Introduction}
Due to the popularization of acquisition devices and techniques, such as 3D scanners and photogrammetry, point clouds are becoming a common representation in many application domains. Their main advantage is the simplicity of the data, since no adjacency information is stored. However, this lack of connectivity also renders point clouds challenging in some important aspects, such as reconstruction and visualization.

An important challenge in this field is the extraction of structured information from the point sets. Even though scanners are able to produce datasets in the order of billions of points, often a more compact representation is possible and desired. For example, the set of points representing a plane can be highly redundant, and may be traded for a simple definition of the plane and its physical boundaries.

Another matter with this representations is visualization, since graphics hardware are tailored to deal with triangle meshes. Directly rendering point clouds has also been the focus of many research efforts, to avoid converting the point set to a mesh for example. Nevertheless, our interest lies on the direct visualization of the extracted primitives.

In this work, we propose a primitive extractor from point clouds, and a coupled ray-tracer to directly render our compact structure. An important step in our algorithm is the detection of geometric primitives, such as planes, spheres, cones, cylinders and tori. Having extracted these primitives we delimit their shapes and extract their boundaries to respect as closely as possible the point set. The shape representation is directly visualized using a ray-tracer, to avoid conversions.


\section{Primitive Extraction from Point Clouds}

Our algorithm is based on the Random Sample Consensus (RANSAC) paradigm \cite{Fischler81}, a way to fit a model into experimental data. Traditional methods for model fitting try to use most of the available points, where the RANSAC paradigm works in the opposite way, using only the minimum number of points to describe a model (ex. three points completely define a plane).

Briefly, the procedure works in the following way: given a number of points $P$ and a minimal number of points $n$ that describe a model, we randomly select a subset of $n$ points from $P$ and create a model $M_1$. Subsequently, we validate $M_1$ by checking how many $n_1$ points from $P$ are within an error tolerance $\epsilon$ to $M_1$. If $n_1$ is larger than a given threshold $t$, we accept $M_1$ and use the selected $n_1$ points to calculate a new refined model $M_1^*$. Otherwise, we start the process again by choosing new random points and creating a new model. If, after some trials, no better consensus has been found, we either choose the one with largest consensus during previous iterations or we terminate the algorithm with failure (in case there was no large enough consensus).

\subsection{Detecting shapes}

We detect shapes in points clouds by using the algorithm developed by Schabel \cite{schnabel07}. The algorithm works by using the RANSAC procedure where in each iteration a minimal number of points is randomly selected to create one of the possible primitives: sphere, plane, torus, cylinder and cones. When a model of a primitive is accepted, the candidates that fall on the primitive are extracted from the point cloud. The method continues until there are no points left, or no primitive can be extracted given the thresholds. \figref{peresult} shows an example of an input point cloud to the algorithm.

Even though this basic method is sound, without further optimizations it suffers heavily of performance issues. However, under the assumption that shapes are a local phenomena, we do not need to create a minimal set by choosing randomly from all the points, we choose points that are spatially close. Exploiting this assumption, we use an octree to establish spatial proximity between points, so we only form a candidate set from points of the same cell.

Every time a primitive is extracted we perform a refitting step using non-linear least squares. Using Newton's algorithm, we refine the extracted primitive model by using all points that were considered to belong to that primitive, and not only the initial random candidates. Finally, we further refine our set of points that belong to the primitive as those that lie at most at a distance of $3\epsilon$, where $\epsilon$ is the distance threshold.

\tsubimages[ht]{ A real case example, from the top and bottom sections of a scanned mechanical instrument. Points in red belong to planes; points in blue belong to cylinders; and white points were not assigned to any primitive. Even though the input is noisy, our extractor was able to retrieve most primitives.}{peresult}{
  \begin{center}
    \subimage[Input mesh.]{.45}{mesh2.png}
    \subimage[Detected primitives.]{.45}{primitives.png}
  \end{center}
}

\subsection{Detecting boundaries}

Mathematically, most of our primitives are infinite in space. However, to be able to effectively extract the model represented by the point set, we need to know their limits, e.g., the boundaries of plane in our points cloud. An assumption we made is that all of our inputs are closed models, meaning that every primitive is enclosed by others. From this assumption we can infer that the intersection points between the primitives are part of their boundary. Even so, a shape may still contain "holes", see \figref{peresult}a. Therefore, we not only need to detect outer boundaries, but possibly inner boundaries as well. We approach this issue by doing the following:
\begin{itemize}
	\item Calculating the intersection points;
	\item Classifying the region in space of one primitive in respect to the other primitives.
\end{itemize}

Since we are dealing with any given type of intersection, many can be very challenging to solve analytically, such as the torus-torus intersection. Thus, we create a spatial data structure in order to detect the intersection points. More specifically, a KD-Tree is generated where a subdivision occurs every time a node contains more than one primitive. This process continues until the cell is small enough so that its center might be considered as a close approximation to the intersection point between the shapes.

Finally, we classify the region of one primitive. The idea behind our approach derives from the work of Tilove \cite{tilove77} and the main point is to create a series of membership classification ($MC$) functions for each primitive. Let $P_i$ and $P_j$ be primitives, then we can define a MC function $MC(P_i, P_j)$ which "classifies" $P_i$ with respect to $P_j$. For example, if $P_i$ is a cylinder and $P_j$ is a plane, there are three possible classification of the cylinder with respect to the plane:
\begin{itemize}
	\item The cylinder lies in front of the plane (according to the plane's normal);
	\item The cylinder lies behind the plane;
	\item The plane passes through the cylinder.
\end{itemize}

Note that in this last case, we can say that the cylinder is both in front and behind the plane. We follow this last approach in our work.

So, for each primitive we create a CSG tree where each node represents a classification function of the current primitive and another detected one. Each time we create a new node to add in the tree we classify our current primitive with respect to the new one generating two more nodes. Clearly, the height of our tree is $O(n)$, where $n$ is the number of primitives.

In \figref{boundariesresult} depicts a simple case to illustrate the method. We can see the lines of intersection points resulting from each vertical plane. These lines illustrate the Membership Classification function as well. Each vertical plane divides the bottom plane in two regions, or patches. Taking into account all four vertical planes, a total of eight patches is generated, each of these representing a leaf node in the CSG tree. All plane's points of interest are contained in these patches, so we use this information in the Ray Tracing algorithm.

\tsubimages[ht] {A simple point cloud generated from five planes. This division creates eight patches for the bottom plane and we use this information to determine the plane's boundaries for the ray tracing algorithm.}{boundariesresult}{
  \begin{center}
    \subimage[Point cloud containing five planes.]{.45}{boundaries1.png}
    \subimage[The bottom plane with the intersection lines drawn in cyan.]{.45}{boundaries2.png}
  \end{center}
}

In \figref{cuberesult} an example of a cube is shown. In this case we can clearly see the intersection points delimiting the region of the plane.

\tsubimages[ht] {A point cloud representing a cube. Each edge represented by the intersection of the adjacent plane.}{cuberesult}{
  \begin{center}
    \subimage[Point cloud of the cube.]{.45}{cube1.png}
    \subimage[Front side of the cube with the intersections.]{.45}{cube2.png}
  \end{center}
}

Since each primitive requires a very reduced set of parameters to define it, a CSG tree of primitives is indeed very low memory consuming, even in the face of a large number of shapes. With our representation a primitive can be completely described by its boundary points and its CSG tree.

Even though the CSG tree alone can describe the spatial boundary of the primitive needed for the ray tracing algorithm, we also detect the intersection points because they may be necessary for other types of operations other than visualization.

\section{Ray tracing}

Ray tracing is a common technique used in computer graphics for rendering images by tracing the path of light sources through pixels in a viewplane, and simulating the effects of its intersections with virtual objects within a scene.

Its basic operation is to intersect rays with objects, such as the point cloud primitives extracted by our algorithm, then finding the closest hit point $p$ from a given perspective. After finding $p$, it is only a matter of computing its correct color, primarily by analyzing the light sources around it. Although lights are not strictly needed -- that is, we can just assign a simple shading to every point --, they are important for creating some realism in scenes. Another noticeable step is sampling, where several rays are shot through the same pixel of the viewplane to be interpolated later on. This process usually improves the overall anti-aliasing of scenes, and it is specially important when shooting rays into our primitives extracted from point clouds, instead of objects defined by implicit equations.

\figref{raytracing} illustrates an overview of our algorithm. It works like a conventional ray-tracer; the most remarkable difference is the intersection of rays using the structures from the extraction algorithm. First, a hit function computes the point of intersection between the primitives and a given ray. Then, the hit point is traversed through the CSG tree. If it reaches a leaf node that is not null, then the point has hit a patch and makes part of our primitive, on the contrary, we discard this point since it is outside the boundaries.

\singleimage[ht]{The ray tracing algorithm builds an image by shooting and extending rays through the scene. \label{fig:raytracing}}{.7}{raytracing.png}

\section{Results}

All code was developed in the C++ programming language, and the ray-tracer was primarily based on the work of Suffern\cite{suffern2007ray}, although we introduced some small differences in our design.

\figref{raytracedcube} shows the result of submitting the extracted primitives from a cube point cloud with 6000 points to our ray-tracer. The extraction process took about one second, while the ray tracing took over two seconds, using, however, ten samples per pixel. Even though the results are still preliminary, the extraction, boundary retrieval, and rendering were accurately achieved with this simple example.

\singleimage[ht]{The cube point cloud, rendered with the ray-tracer.\label{fig:raytracedcube}}{.69}{raytracedcube.png}


\section{Conclusions}

Once the primitives are extracted and their boundaries computed, we achieve a very compact representation that can replace the entire point cloud in many situations.
This is specially interesting in some fields such as mechanical pieces, where the primitives can describe the objects in a very compact and precise way. Even more, this leads to a possibly noise free representation that is useful in many domains.
The coupled ray-tracer brings even more power to our compact representation, since conversion to triangle meshes, for example, becomes unnecessary.

At this point, the strongest limitation is that our algorithm is not scalable to a large number of primitives, since the memory to calculate all intersections becomes impracticable. 

\section{Future Work}

We list some important aspects that we would like to improve in our approach:
\begin{itemize}
\item improve the overall performance of the primitive extraction. Although it is able to handle small datasets without significant noise, its accuracy drops considerably in real case scenarios;
\item due to the lack of accuracy in more complex models, we are not yet able to produce good CSG trees for all primitives. Consequently, the regions are not well delimited , causing erroneous renderings with the ray tracing. This is the reason that only a simple primitive -- the cube -- was shown here as a result within the complete extraction and rendering pipeline. We are currently working on solving this issue to work with more complex point clouds.
\item store and use only information from the boundary points and the CSG tree to improve memory efficiency;
\item improve the overall performance and efficiency of the ray-tracer, for example, by parallelizing it using multiple processing cores, and by implementing some acceleration schemes, such as regular grids.
\end{itemize}

%\iffinal

% FIXME
%\section*{Acknowledgments}
%The authors would like to thank ...
%\fi

% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
% \IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
% \IEEEtriggercmd{\enlargethispage{-5in}}

\bibliographystyle{IEEEtran}
\bibliography{references}

% \emph{SIBGRAPI 2014, Proceedings of the XXVII Brazilian Symposium on Computer Graphics and Image Processing}.\hskip 1em plus 0.5em minus 0.4em\relax  Rio de Janeiro, Brazil: {IEEE}, August 2014.

\end{document}
